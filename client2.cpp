#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string>
struct header
{
    char magic1;
    char magic2;
    char opcode;
    char payload_len;
    uint32_t token;
    uint32_t msg_id;
};
const int h_size = sizeof(struct header);
#define MAGIC_1 'T'
#define MAGIC_2 'C'
// These are the constants indicating the states.
#define STATE_OFFLINE 0
#define STATE_LOGIN_SENT 1
#define STATE_ONLINE 2
#define STATE_POST_SENT 3
#define STATE_RETRIEVE_SENT 4
#define STATE_LOGOUT_SENT 5
#define STATE_SUBSCRIBE_SENT 6
#define STATE_UNSUBSCRIBE_SENT 7
// Now you can define other states in a similar fashion.
// These are the constants indicating the events.
// All events starting with EVENT_USER_ are generated by a human user.
#define EVENT_USER_LOGIN 0
#define EVENT_USER_POST 1
#define EVENT_USER_SUBSCRIBE 2
#define EVENT_USER_UNSUBSCRIBE 3
#define EVENT_USER_RETRIEVE 4
#define EVENT_USER_LOGOUT 5
#define EVENT_USER_RESET 6
#define EVENT_USER_INVALID 79
// All events starting with EVENT_NET_ are generated by receiving a msg
// from the network. We deliberately use larger numbers to help debug.
#define EVENT_NET_LOGIN_SUCCESSFUL 80
#define EVENT_NET_POST_ACK 81
#define EVENT_NET_LOGIN_FAILED 82
#define EVENT_NET_FORWARD 83
#define EVENT_NET_MUST_LOGIN 84
#define EVENT_NET_SUBSCRIBE_SUCCESSFUL 85
#define EVENT_NET_SUBSCRIBE_FAILED 86
#define EVENT_NET_UNSUBSCRIBE_SUCCESSFUL 87
#define EVENT_NET_UNSUBSCRIBE_FAILED 88
#define EVENT_NET_RETRIEVE_ACK 89
#define EVENT_NET_END_RETRIEVE_ACK 90
#define EVENT_NET_LOGOUT_ACK 91
#define EVENT_NET_RESET 92

// Now you can define other events from the network.......
#define EVENT_NET_INVALID 255
// These are the constants indicating the opcodes.
#define OPCODE_RESET 0x00
#define OPCODE_MUST_LOGIN_FIRST_ERROR 0xF0
#define OPCODE_LOGIN 0x10
#define OPCODE_SUCCESSFUL_LOGIN_ACK 0x80
#define OPCODE_FAILED_LOGIN_ACK 0x81
#define OPCODE_SUBSCRIBE 0x20
#define OPCODE_SUCCESSFUL_SUBSCRIBE_ACK 0x90
#define OPCODE_FAILED_SUBSCRIBE_ACK 0x91
#define OPCODE_UNSUBSCRIBE 0x21
#define OPCODE_SUCCESSFUL_UNSUBSCRIBE_ACK 0xA0
#define OPCODE_FAILED_UNSUBSCRIBE_ACK 0xA1
#define OPCODE_POST 0x30
#define OPCODE_POST_ACK 0xB0
#define OPCODE_FORWARD 0xB1
#define OPCODE_FORWARD_ACK 0x31
#define OPCODE_RETRIEVE 0x40
#define OPCODE_RETRIEVE_ACK 0xC0
#define OPCODE_END_OF_RETRIEVE_ACK 0xC1
#define OPCODE_LOGOUT 0x1F
#define OPCODE_LOGOUT_ACK 0x8F


int parse_the_event_from_the_input_string(char buf[1024])
{
    if(strncmp(buf,"login#",6) == 0)
    {
        return EVENT_USER_LOGIN;
    }else if(strncmp(buf,"post#",5) == 0)
    {
        return EVENT_USER_POST;
    }
    else if(strncmp(buf,"retrieve#",9) == 0)
    {
        return EVENT_USER_RETRIEVE;
    }
    else if(strncmp(buf,"logout#",7) == 0)
    {
        return EVENT_USER_LOGOUT;
    }
    else if(strncmp(buf,"subscribe#",10) == 0)
    {
        return EVENT_USER_SUBSCRIBE;
    }
    else if(strncmp(buf,"unsubscribe#",12) == 0)
    {
        return EVENT_USER_UNSUBSCRIBE;
    }
    else if(strncmp(buf,"reset#",6))
    {
        return EVENT_USER_RESET;
    }else{
        return EVENT_USER_INVALID;
    }
}


int parse_the_event_from_the_received_message(struct header* r)
{
  //  printf("getting your event now\n");
  //  printf("this is the opcode %x\n", r->opcode);
   // printf("the opcode for success: %x\n",OPCODE_SUCCESSFUL_LOGIN_ACK);
    if((r->opcode & 0xFF) == OPCODE_FAILED_LOGIN_ACK) //failed login
    {
        return EVENT_NET_LOGIN_FAILED;

    }else if((r->opcode & 0xFF) == OPCODE_SUCCESSFUL_LOGIN_ACK)//successful login
    {
        return EVENT_NET_LOGIN_SUCCESSFUL;

    }else if((r->opcode & 0xFF) == OPCODE_MUST_LOGIN_FIRST_ERROR) //must login error
    {
        return EVENT_NET_MUST_LOGIN;

    }else if((r->opcode & 0xFF) == OPCODE_SUCCESSFUL_SUBSCRIBE_ACK) //successful subscription
    {
        return EVENT_NET_SUBSCRIBE_SUCCESSFUL;

    }else if((r->opcode & 0xFF) == OPCODE_FAILED_SUBSCRIBE_ACK) //failed subscription
    {
        return EVENT_NET_SUBSCRIBE_FAILED;

    }else if((r->opcode & 0xFF) == OPCODE_SUCCESSFUL_UNSUBSCRIBE_ACK) //successful unsubscription
    {
        return EVENT_NET_UNSUBSCRIBE_SUCCESSFUL;

    }else if((r->opcode & 0xFF) == OPCODE_FAILED_UNSUBSCRIBE_ACK) //failed unsubscription
    {
        return EVENT_NET_UNSUBSCRIBE_FAILED;

    }else if((r->opcode & 0xFF) == OPCODE_POST_ACK)//post
    {
        return EVENT_NET_POST_ACK;

    }else if((r->opcode & 0xFF) == OPCODE_FORWARD) //forward
    {
        return EVENT_NET_FORWARD;

    }else if((r->opcode & 0xFF) == OPCODE_RETRIEVE_ACK) //retrieve ack
    {
        return EVENT_NET_RETRIEVE_ACK;

    }else if((r->opcode & 0xFF) == OPCODE_END_OF_RETRIEVE_ACK)//end of retrieve
    {
        return EVENT_NET_END_RETRIEVE_ACK;

    }else if((r->opcode & 0xFF) == OPCODE_LOGOUT_ACK) //logout ack
    {
        return EVENT_NET_LOGOUT_ACK;

    }else if((r->opcode & 0xFF) == OPCODE_RESET)
    {
        return EVENT_NET_RESET;
    }
    else{//error has occured
        return EVENT_NET_INVALID;

    }
}
void send_reset(int sockfd, char* buf)
{
    struct header* ph_send = (struct header*) buf;
    ph_send->magic1 = MAGIC_1;
    ph_send->magic2 = MAGIC_2;
    ph_send->opcode = OPCODE_RESET;
    ph_send->msg_id = 0;
    ph_send->token = 0;
    ph_send->payload_len = 0;
    send(sockfd,buf,sizeof(buf),0);
}

int main()
{
    char user_input[1024];
    int ret;
    int sockfd = 0;
    char send_buffer[1024];
    char recv_buffer[1024];
    struct sockaddr_in serv_addr;
    struct sockaddr_in my_addr;
    int maxfd;
    fd_set read_set;
    FD_ZERO(&read_set);
    // You just need one socket file descriptor. I made a mistake previously
    // and defined two socket file descriptors.
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        printf("socket() error: %s.\n", strerror(errno));
        return -1;
    }
    // The "serv_addr" is the server's address and port number,
    // i.e, the destination address if the client needs to send something.
    // Note that this "serv_addr" must match with the address in the
    // "UDP receive" code.
    // We assume the server is also running on the same machine, and
    // hence, the IP address of the server is just "127.0.0.1".
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    serv_addr.sin_port = htons(32000);
    // The "my_addr" is the client's address and port number used for
    // receiving responses from the server.
    // Note that this is a local address, not a remote address.
    memset(&my_addr, 0, sizeof(my_addr));
    my_addr.sin_family = AF_INET;
    my_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    my_addr.sin_port = htons(rand());
    // Bind "my_addr" to the socket for receiving messages from the server.
    bind(sockfd,
         (struct sockaddr *)&my_addr,
         sizeof(my_addr));
    maxfd = sockfd + 1;
    // Note that the file descriptor of stdin is "0"
    int state = STATE_OFFLINE;
    int event;
    uint32_t token;
    int wantedMessages;
    // Assume the token is a 32-bit integer
    // This is a pointer of the type "struct header" but it always points
    // to the first byte of the "send_buffer", i.e., if we dereference this
    // pointer, we get the first 12 bytes in the "send_buffer" in the format
    // of the structure, which is very convenient.
    struct header *ph_send = (struct header *)send_buffer;
    // So as the receive buffer.
    struct header *ph_recv = (struct header *)recv_buffer;
    memset(send_buffer,0,sizeof(send_buffer));
    memset(recv_buffer,0,sizeof(recv_buffer));
    while (1)
    {
        // Use select to wait on keyboard input or socket receiving.
        FD_SET(fileno(stdin), &read_set);
        FD_SET(sockfd, &read_set);
        select(maxfd, &read_set, NULL, NULL, NULL);
        if (FD_ISSET(fileno(stdin), &read_set))
        {
            // Now we know there is a keyboard input event
            // TODO: Figure out which event and process it according to the
            // current state
            fgets(user_input, sizeof(user_input), stdin);
            // Note that in this parse function, you need to check the
            // user input and figure out what event it is. Basically it
            // will be a long sequence of if (strncmp(user_input, ...) == 0)
            // and if none of the "if" matches, return EVENT_USER_INVALID
            event = parse_the_event_from_the_input_string(user_input);
            // You can also add a line to print the "event" for debugging.
            memset(send_buffer,0,sizeof(send_buffer));
            if (event == EVENT_USER_LOGIN)
            {
                if (state == STATE_OFFLINE)
                {
                    // CAUTION: we do not need to parse the user ID and
                    // and password string, assuming they are always in the
                    // correct format. The server will parse it anyway.
                    char *id_password = user_input + 6; // skip the "login#"
                    int m = strlen(id_password);
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_LOGIN;
                    ph_send->payload_len = m;
                    ph_send->token = 0;
                    ph_send->msg_id = 0;
                    memcpy(send_buffer + h_size, id_password, m);
                    sendto(sockfd,
                           send_buffer,
                           h_size + m,
                           0,
                           (struct sockaddr *)&serv_addr, sizeof(serv_addr));
                    // Once the corresponding action finishes, transit to
                    // the login_sent state
                    state = STATE_LOGIN_SENT;
                }
                else
                {
                    // handle errors if the event happens in a state
                    // that is not expected. Basically just print an error
                    // message and doing nothing. Note that if a user types
                    // something invalid, it does not need to trigger a
                    // session reset.
                    printf("error#can't_login\n");
                }
            }
            else if (event == EVENT_USER_POST)
            {
                // Note that this is similar to the login msg.
                // Actually, these messages are carefully designed to
                // somewhat minimize the processing on the client side.
                // If you look at the "subscribe", "unsubscribe", "post"
                // and "retrieve", they are all similar, i.e., just fill
                // the header and copy the user input after the "#" as
                // the payload of the message, then just send the msg.
                char *text = user_input + 5; // skip the "post#"
                int m = strlen(text);
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_POST;
                ph_send->payload_len = m;
                ph_send->token = token;
                ph_send->msg_id = 0;
                memcpy(send_buffer + h_size, text, m);
                sendto(sockfd,
                       send_buffer,
                       h_size + m,
                       0,
                       (struct sockaddr *)&serv_addr,
                       sizeof(serv_addr));
                state = STATE_POST_SENT;
            }
            else if (event == EVENT_USER_RESET)
            {
                
                //send_reset(sockfd,send_buffer);

                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_RESET;
                ph_send->token = token;
                ph_send->msg_id = 0;
                ph_send->payload_len = 0;
                sendto(sockfd,
                       send_buffer,
                       h_size,
                       0,
                       (struct sockaddr *)&serv_addr,
                       sizeof(serv_addr));

                state = STATE_OFFLINE;
            }
            else if (event == EVENT_USER_SUBSCRIBE /* some other event */)
            {
                char *text = user_input + 10; // skip the "post#"
                int m = strlen(text);
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_SUBSCRIBE;
                ph_send->payload_len = m;
                ph_send->token = token;
                ph_send->msg_id = 0;
                
                memcpy(send_buffer + h_size, text, m);
                sendto(sockfd,
                       send_buffer,
                       h_size + m,
                       0,
                       (struct sockaddr *)&serv_addr,
                       sizeof(serv_addr));
                state = STATE_SUBSCRIBE_SENT;

                // TODO: process other event
            }else if(event == EVENT_USER_UNSUBSCRIBE/* unsub from this person*/)
            {
                char *text = user_input + 12; // skip the "post#"
                int m = strlen(text);
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_UNSUBSCRIBE;
                ph_send->payload_len = m;
                ph_send->token = token;
                ph_send->msg_id = 0;
                
                memcpy(send_buffer + h_size, text, m);
                sendto(sockfd,
                       send_buffer,
                       h_size + m,
                       0,
                       (struct sockaddr *)&serv_addr,
                       sizeof(serv_addr));
                state = STATE_UNSUBSCRIBE_SENT;
            }else if(event == EVENT_USER_RETRIEVE)
            {
                char *text = user_input + 9;
                std::string num = text;
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_RETRIEVE;
                ph_send->payload_len = stoi(num);
                ph_send->token = token;
                ph_send->msg_id = 0;
                wantedMessages = stoi(num);
                sendto(sockfd,
                       send_buffer,
                       h_size,
                       0,
                       (struct sockaddr *)&serv_addr,
                       sizeof(serv_addr));
                state = STATE_RETRIEVE_SENT;
            }else if(event == EVENT_USER_INVALID)
            {
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = 0xA2;
                ph_send->msg_id = 0;
                ph_send->token = token;
                ph_send->payload_len = 0;
                sendto(sockfd,
                       send_buffer,
                       h_size,
                       0,
                       (struct sockaddr *)&serv_addr,
                       sizeof(serv_addr));
            }else if(event == EVENT_USER_LOGOUT)
            {
                if(state == STATE_ONLINE)
                {
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_LOGOUT;
                    ph_send->msg_id = 0;
                    ph_send->token = token;
                    ph_send->payload_len = 0;
                    sendto(sockfd,
                        send_buffer,
                        h_size,
                        0,
                        (struct sockaddr *)&serv_addr,
                        sizeof(serv_addr));
                    state = STATE_LOGOUT_SENT;

                }else{
                    printf("Error#Can't_log_out\n");
                    state = STATE_OFFLINE;
                }
                
            }
        }
        if (FD_ISSET(sockfd, &read_set))
        {
            // Now we know there is an event from the network
            // TODO: Figure out which event and process it according to the
            // current state
            memset(recv_buffer,0,sizeof(recv_buffer));
            ret = recv(sockfd, recv_buffer, sizeof(recv_buffer), 0);
            event = parse_the_event_from_the_received_message(ph_recv);
          //  printf("your event is %d\n",event);
            if (event == EVENT_NET_LOGIN_SUCCESSFUL)
            {
              //  printf("Yay you logged in!\n");
                if (state == STATE_LOGIN_SENT)
                {
                    token = ph_recv->token;
                    // TODO: print a line of "login_ack#successful"
                    printf("login_ack#successful\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    // A spurious msg is received. Just reset the session.
                    //send_reset(sockfd, send_buffer);
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_RESET;
                    ph_send->msg_id = 0;
                    ph_send->payload_len = 0;
                    sendto(sockfd,
                        send_buffer,
                        h_size,
                        0,
                        (struct sockaddr *)&serv_addr,
                        sizeof(serv_addr));


                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_LOGIN_FAILED)
            {
                if (state == STATE_LOGIN_SENT)
                {
                    // TODO: print a line of "login_ack#failed"
                    printf("login_ack#failed\n");
                    state = STATE_OFFLINE;
                }
                else
                {
                    //send_reset(sockfd, send_buffer);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_RESET;
                    ph_send->msg_id = 0;
                    ph_send->payload_len = 0;
                    sendto(sockfd,
                        send_buffer,
                        h_size,
                        0,
                        (struct sockaddr *)&serv_addr,
                        sizeof(serv_addr));

                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_FORWARD)
            {
                if (state == STATE_ONLINE)
                {
                    // Just extract the payload and print the text.
                    //printf("The length: %d\n",(ph_recv->payload_len));
                    char *text = recv_buffer + h_size;
                    printf("%s\n", text);
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_FORWARD_ACK;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = ph_recv->msg_id;

                    sendto(sockfd,
                        send_buffer,
                        h_size,
                        0,
                        (struct sockaddr *)&serv_addr,
                        sizeof(serv_addr));
                    // Note that no state change is needed.
                }
                else
                {
                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_FORWARD_ACK;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = ph_recv->msg_id;

                    sendto(sockfd,
                        send_buffer,
                        h_size,
                        0,
                        (struct sockaddr *)&serv_addr,
                        sizeof(serv_addr));
                }
            }else if( event == EVENT_NET_POST_ACK)
            {
                if(state == STATE_POST_SENT)
                {
                    printf("post_ack#successful\n");
                }
                state = STATE_ONLINE;
                
            }
            else if (event == EVENT_NET_SUBSCRIBE_SUCCESSFUL)
            {
                if(state == STATE_SUBSCRIBE_SENT)
                {
                    printf("subscribe_ack#successful\n");
                }
                state = STATE_ONLINE;
               
            }else if(event == EVENT_NET_SUBSCRIBE_FAILED)
            {
                printf("subscribe_ack#failed\n");
                state = STATE_ONLINE;
            }else if(event == EVENT_NET_UNSUBSCRIBE_SUCCESSFUL)
            {
                printf("unsubscribe_ack#successful\n");
                state = STATE_ONLINE;
            }else if(event == EVENT_NET_UNSUBSCRIBE_FAILED)
            {
                printf("unsubscribe_ack#failed\n");
                state = STATE_ONLINE;
            }else if(event == EVENT_NET_RETRIEVE_ACK)
            {
                char *text = recv_buffer + h_size;
                printf("%s\n", text);
            }else if(event == EVENT_NET_END_RETRIEVE_ACK)
            {
                state = STATE_ONLINE;
            }else if(event == EVENT_NET_RESET)
            {
                printf("Session reset\n\n");
                state = STATE_OFFLINE;
            }else if(event == EVENT_NET_MUST_LOGIN)
            {
                printf("error#Must_login\n");
                state = STATE_OFFLINE;
            }else if(event == EVENT_NET_LOGOUT_ACK)
            {
                printf("logout#successful\n");
                state = STATE_OFFLINE;
                token = 0;
            }
        } // Now we finished processing the pending event. Just go back to the
        // beginning of the loop and waiting for another event.
        // Note that you can set a timeout for the select() function
        // to allow it to return regularly and check timeout related events.
    }
    // This is the end of the while loop
}
// This is the end of main()